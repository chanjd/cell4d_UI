[{"/mnt/c/Users/Donny/Documents/cell4d-react/src/schema.ts":"1","/mnt/c/Users/Donny/Documents/cell4d-react/src/Header/Header.tsx":"2","/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/FormEnv/FormEnv.tsx":"3","/mnt/c/Users/Donny/Documents/cell4d-react/src/xml_validate.ts":"4","/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/FormComparts/FormComparts.tsx":"5","/mnt/c/Users/Donny/Documents/cell4d-react/src/TabComponent/TabComponent.tsx":"6","/mnt/c/Users/Donny/Documents/cell4d-react/src/App.tsx":"7","/mnt/c/Users/Donny/Documents/cell4d-react/src/index.tsx":"8","/mnt/c/Users/Donny/Documents/cell4d-react/src/optional.ts":"9","/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/FormAnnot/FormAnnot.tsx":"10","/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/formInitialState.ts":"11","/mnt/c/Users/Donny/Documents/cell4d-react/src/VisualizeModel/VisualizeModel.tsx":"12","/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/colorPicker.tsx":"13","/mnt/c/Users/Donny/Documents/cell4d-react/src/modelContext.ts":"14","/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/FormSpecies/FormSpecies.tsx":"15","/mnt/c/Users/Donny/Documents/cell4d-react/src/types.ts":"16"},{"size":12128,"mtime":1610576435771,"results":"17","hashOfConfig":"18"},{"size":5394,"mtime":1610589152524,"results":"19","hashOfConfig":"18"},{"size":8814,"mtime":1610592511538,"results":"20","hashOfConfig":"18"},{"size":44231,"mtime":1609957881968,"results":"21","hashOfConfig":"18"},{"size":13489,"mtime":1610663308453,"results":"22","hashOfConfig":"18"},{"size":1920,"mtime":1610592095797,"results":"23","hashOfConfig":"18"},{"size":3384,"mtime":1610589128350,"results":"24","hashOfConfig":"18"},{"size":599,"mtime":1608318914130,"results":"25","hashOfConfig":"18"},{"size":710,"mtime":1606692077052,"results":"26","hashOfConfig":"18"},{"size":16652,"mtime":1610663397634,"results":"27","hashOfConfig":"18"},{"size":2421,"mtime":1610662670618,"results":"28","hashOfConfig":"18"},{"size":542,"mtime":1607531779003,"results":"29","hashOfConfig":"18"},{"size":1511,"mtime":1609952662725,"results":"30","hashOfConfig":"18"},{"size":592,"mtime":1610664548337,"results":"31","hashOfConfig":"18"},{"size":19697,"mtime":1610935223953,"results":"32","hashOfConfig":"18"},{"size":0,"mtime":1610576065493,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"1gobh53",{"filePath":"36","messages":"37","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"40","messages":"41","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"52"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/mnt/c/Users/Donny/Documents/cell4d-react/src/schema.ts",["70","71"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/Header/Header.tsx",["72","73","74","75","76","77"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/FormEnv/FormEnv.tsx",["78","79","80"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/xml_validate.ts",["81","82","83","84","85","86","87","88","89","90","91","92","93","94","95"],"// import * as yup from 'yup'; // for everything\nimport { schema } from './schema';\nimport \"./optional\"; // custom \"optional\" function for yup validation\nimport { ValidationError } from 'yup';\ndeclare var require: any\nconst { strict, match } = require(\"assert\");\nconst { ENGINE_METHOD_DSA } = require(\"constants\");\nconst fs = require(\"fs\")\n// import xmlParser from \"fast-xml-parser\";\nconst xmlParser = require('xml-js');\n\n// const jsonParser = require(\"fast-xml-parser\").j2xParser;\n\ninterface validationError {\n\tpath: string,\n\tmessage: string\n}\n\nfunction isPositiveInt(str: any) {\n\treturn !isNaN(str) && Number.isInteger(parseFloat(str)) && str >= 0;\n}\n\nlet get_env = function (model_obj: any): any {\n\tlet env_model = model_obj?.[\"annotation\"]?.[\"cell4d:environmentVariables\"];\n\tif (!env_model) {\n\t\treturn false;\n\t}\n\treturn (env_model);\n}\n\n// case insensitive string matching to target list\nlet is_correct_string = function (input: string, valid_strings: Array<string>): boolean {\n\tvalid_strings = valid_strings.map(function (x) { return x.toLocaleUpperCase(); });\n\tif (input && valid_strings.includes(input.toLocaleUpperCase())) {\n\t\treturn (true);\n\t}\n\treturn (false);\n}\n\nlet is_in_range = function (input: number, valid_range: Array<number>): boolean {\n\tif (valid_range.length != 2) {\n\t\tconsole.error(`Invalid range ${valid_range} used in is_in_range() call`)\n\t}\n\tif (valid_range[0] > valid_range[1]) {\n\t\tvalid_range = [valid_range[1], valid_range[0]];\n\t}\n\tif (!isNaN(input) && input >= valid_range[0] && input <= valid_range[1]) {\n\t\treturn (true);\n\t}\n\n\treturn (false);\n}\n\n// validate env variables\nlet validate_env = function (env_model: any, schema: any): { pass: boolean, errors: Array<string>, longErrors: Array<validationError> } {\n\tlet output = { pass: true, errors: Array<string>(), longErrors: Array<validationError>() }\n\n\tlet validity = schema.isValidSync(env_model);\n\tlet validate_errors: Array<string> = [];\n\tlet long_errors: Array<validationError> = [];\n\ttry {\n\t\tschema.validateSync(env_model, { abortEarly: false });\n\t} catch (error) {\n\t\tlong_errors = error.inner.map((error_element: any) => {\n\t\t\treturn ({\n\t\t\t\tpath: error_element.path,\n\t\t\t\tmessage: error_element.message\n\t\t\t})\n\t\t})\n\t\tvalidate_errors = error.errors;\n\t}\n\n\toutput.pass = validity;\n\toutput.errors = validate_errors;\n\toutput.longErrors = long_errors;\n\treturn (output)\n}\n\nlet validate_comparts = function (compart_model: any, schema: any): { pass: boolean, errors: Array<string>, longErrors: Array<validationError> } {\n\tlet output = { pass: true, errors: Array<string>(), longErrors: Array<validationError>() }\n\n\t// if (!Array.isArray(compart_model)) compart_model = [compart_model];\n\tlet validate_errors: Array<string> = [];\n\tlet long_errors: Array<validationError> = [];\n\n\t// grab all errors thrown by validateSync\n\ttry {\n\t\tschema.validateSync(compart_model, { abortEarly: false });\n\t} catch (error) {\n\t\tif(error instanceof ValidationError) {\n\t\t\tlong_errors = error.inner.map((error_element: any) => {\n\t\t\t\treturn ({\n\t\t\t\t\tpath: error_element.path,\n\t\t\t\t\tmessage: error_element.message\n\t\t\t\t})\n\t\t\t})\n\t\t\tlet error_out = error.errors;\n\t\t\tvalidate_errors = [...validate_errors, ...error_out];\n\t\t} else {\n\t\t\tconsole.log();\n\t\t}\n\t}\n\n\tif (validate_errors.length !== 0) output.pass = false;\n\toutput.errors = validate_errors;\n\toutput.longErrors = long_errors;\n\n\treturn (output);\n}\n\nlet validate_annot_species = function (annot_model: any, compart_list: Array<string>, schema: any): { pass: boolean, errors: Array<string>, longErrors: Array<validationError> } {\n\tlet output = { pass: true, errors: Array<string>(), longErrors: Array<validationError>() }\n\tlet validate_errors: Array<string> = [];\n\tlet long_errors: Array<validationError> = [];\n\n\t// grab all errors thrown by validateSync\n\ttry {\n\t\t// provide compartment list to schema-generation function\n\t\tschema(compart_list).validateSync(annot_model, { abortEarly: false });\n\n\t\t// step through each base molecule to check for bulk binding sites\n\t\tObject.values(annot_model[\"cell4d:speciesType\"]).forEach(function (annot: any) {\n\t\t\t// workaround, disallow bulk from having binding sites\n\t\t\tif (annot?._attributes?.speciesMoleculeType === \"SIMPLE_MOLECULE\") {\n\t\t\t\tif (annot?.[\"cell4d:listOfBindingSites\"]) {\n\t\t\t\t\tvalidate_errors = [...validate_errors, \"invalid_var\"];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (error) {\n\t\tlong_errors = error.inner.map((error_element: any) => {\n\t\t\treturn ({\n\t\t\t\tpath: error_element.path,\n\t\t\t\tmessage: error_element.message\n\t\t\t})\n\t\t})\n\t\tlet error_out = error.errors;\n\t\tvalidate_errors = [...validate_errors, ...error_out];\n\t}\n\n\tif (validate_errors.length !== 0) output.pass = false;\n\toutput.errors = validate_errors;\n\toutput.longErrors = long_errors;\n\n\treturn (output);\n}\n\n\nlet validate_species = function (species_model: any, compart_list: Array<string>, annotspecies_bindings_list: any): { pass: boolean; errors: Array<string>; } {\n\tlet output = { pass: true, errors: Array<string>() }\n\tlet possible_errors = [\"missing_var\", \"invalid_var\", \"no_match\"];\n\tObject.values(species_model).forEach(function (species: any) {\n\t\tif (!species.id) {\n\t\t\tconsole.log(\"species must have id attribute\");\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t}\n\t\tif (!species[\"annotation\"]) {\n\t\t\tconsole.log(\"species information must be inside annotation tags\");\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\treturn;\n\t\t}\n\n\t\t// check compartments\n\t\tlet compartments_list;\n\t\tif (species?.[\"annotation\"]?.[\"cell4d:listOfValidCompartments\"]?.[\"cell4d:compartment\"] === undefined) {\n\t\t\tconsole.log(`species ${species.id} missing valid compartment info`);\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t} else {\n\t\t\tcompartments_list = species[\"annotation\"][\"cell4d:listOfValidCompartments\"][\"cell4d:compartment\"];\n\t\t\tfor (let i = 0; i < compartments_list.length; i++) {\n\t\t\t\tif (!compartments_list[i].id) {\n\t\t\t\t\tconsole.log(\"initial compartment id must be specified\");\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t} else if (!compart_list.includes(compartments_list[i].id)) {\n\t\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t\t}\n\t\t\t\tif (!compartments_list[i].initial) {\n\t\t\t\t\tconsole.log(`initial placement counts of ${species.id} in ${compartments_list[i].id} must be specified (can be 0)`);\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t} else if (!isPositiveInt(compartments_list[i].initial)) {\n\t\t\t\t\tconsole.log(`initial counts of ${species.id} in ${compartments_list[i].id} must be a positive integer`);\n\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (species?.[\"annotation\"]?.[\"cell4d:listOfSpeciesTypes\"]?.[\"cell4d:speciesType\"] === undefined) {\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t} else {\n\t\t\tlet species_types = species[\"annotation\"][\"cell4d:listOfSpeciesTypes\"][\"cell4d:speciesType\"]\n\t\t\tif (!Array.isArray(species_types)) species_types = [species_types];\n\t\t\tfor (let species_type of species_types) {\n\t\t\t\tlet species_sites = species_type[\"cell4d:bindingSite\"];\n\t\t\t\tif (!species_sites) species_sites = [];\n\t\t\t\t// there is a difference between bind sites and mod sites. only 1 of state and binding should be filled\n\t\t\t\tfor (let species_site of species_sites) {\n\t\t\t\t\t// state XOR binding filled\n\t\t\t\t\tif (!(species_site.state === \"\") ? !(species_site.binding === \"\") : (species_site.binding === \"\")) {\n\t\t\t\t\t\tconsole.log(`Species ${species_type.id}: only 1 of state or binding site should be filled`);\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t}\n\t\t\t\t\t// if binding filled, must be target strings\n\t\t\t\t\tif (!(is_correct_string(species_site.binding, [\"unbind\", \"unbound\", \"bind\", \"bound\"])) && species_site.binding !== \"\") {\n\t\t\t\t\t\tconsole.log(`Species ${species_type.id}: invalid binding parameter ${species_site.binding}`);\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't allow wildcard matches, all bind sites/states must be filled in species info\n\t\t\t\tif (!match_species(species_type, annotspecies_bindings_list)) {\n\t\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// diffusionConstant and displayProperties are optional here, validate if exists\n\t\tif (species[\"annotation\"][\"cell4d:diffusionConstant\"]) {\n\t\t\tlet difc = species[\"annotation\"][\"cell4d:diffusionConstant\"].value;\n\t\t\tif (!is_in_range(difc, [0, 1])) {\n\t\t\t\tconsole.log(\"diffusion constant cannot be negative\");\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t}\n\t\tif (species[\"annotation\"][\"cell4d:displayProperties\"]) {\n\t\t\tlet display_colors = [\"redValue\", \"greenValue\", \"blueValue\"];\n\t\t\tfor (const color of display_colors) {\n\t\t\t\tif (!is_in_range(species[\"annotation\"][\"cell4d:displayProperties\"][color], [0, 255])) {\n\t\t\t\t\tconsole.log(\"color properties must be between 0 and 255\")\n\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t})\n\n\tif (output.errors.length !== 0) output.pass = false;\n\treturn (output);\n}\n\n// reaction validation\nlet validate_reactions = function (reactions_model: any, compart_list: Array<string>,\n\tannotspecies_bindings_list: any, metabolite_list: string[]): { pass: boolean; errors: Array<string>; } {\n\tlet output = {\n\t\tpass: true,\n\t\terrors: Array<string>()\n\t}\n\tlet possible_errors = [\"missing_var\", \"invalid_var\", \"no_match\"];\n\tObject.values(reactions_model).forEach(function (reaction: any) {\n\t\tlet reaction_id = reaction.id;\n\t\tlet annotation = reaction[\"annotation\"];\n\t\tlet list_reactants = reaction[\"listOfReactants\"];\n\t\tlet list_modifiers = reaction[\"listOfModifiers\"];\n\t\tlet list_products = reaction[\"listOfProducts\"];\n\t\tif (!list_reactants || !list_modifiers || !list_products) {\n\t\t\tconsole.log(\"missing reactant/product/modifier lists in reaction \" + reaction_id);\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\treturn;\n\t\t}\n\n\t\t// scan optional list of compartments elements in reaction annotation\n\t\tif (annotation) {\n\t\t\tif (annotation[\"cell4d:listOfCompartments\"]) {\n\t\t\t\tlet reaction_comparts = annotation[\"cell4d:listOfCompartments\"][\"cell4d:compartment\"];\n\t\t\t\tif (!reaction_comparts) {\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet reaction_comparts_list: Array<string> = reaction_comparts.map((compart: { id: string; }) => { return compart.id })\n\t\t\t\tfor (let react_compart of reaction_comparts_list) {\n\t\t\t\t\tif (!compart_list.includes(react_compart)) {\n\t\t\t\t\t\tconsole.log(`an allowed compartment of reaction ${reaction_id} does not exist.`)\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check for placeholders, sbml compliance\n\t\tif (!list_reactants[\"speciesReference\"] || !list_products[\"speciesReference\"] || !list_modifiers[\"modifierSpeciesReference\"]) {\n\t\t\tconsole.log(\"reaction list must have 'speciesReference' or 'modifierSpeciesReference' placeholder elements\");\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t} else if (!list_reactants[\"speciesReference\"].species ||\n\t\t\t!list_modifiers[\"modifierSpeciesReference\"].species ||\n\t\t\t!list_products[\"speciesReference\"].species) {\n\t\t\tconsole.log(\"'speciesReference' must have 'species' placeholder attribute\");\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t}\n\n\t\tlet reactants = list_reactants[\"annotation\"][\"cell4d:speciesReference\"];\n\t\tif (!Array.isArray(reactants)) reactants = [reactants];\n\t\tfor (let reactant of reactants) {\n\t\t\tif (reactant?.[\"cell4d:listOfSpeciesTypes\"]?.[\"cell4d:speciesType\"] === undefined) {\n\t\t\t\tconsole.log(\"list of reactants in reaction \" + reaction_id + \" missing species list.\")\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet species_types: Array<any> = reactant[\"cell4d:listOfSpeciesTypes\"][\"cell4d:speciesType\"];\n\t\t\tif (!Array.isArray(species_types)) species_types = [species_types];\n\t\t\tfor (let species_type of species_types) {\n\t\t\t\tif (!species_type.id) {\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet species_sites = species_type[\"cell4d:bindingSite\"];\n\t\t\t\tif (!species_sites) species_sites = [];\n\t\t\t\t// there is a difference between bind sites and mod sites. only 1 of state and binding should be filled\n\t\t\t\tlet invalid_found = false;\n\t\t\t\tfor (let species_site of species_sites) {\n\t\t\t\t\t// state XOR binding filled\n\t\t\t\t\tif (!(species_site.state === \"\") ? !(species_site.binding === \"\") : (species_site.binding === \"\")) {\n\t\t\t\t\t\tconsole.log(`Species ${species_type.id}: only 1 of state or binding site should be filled`);\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t\tinvalid_found = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(is_correct_string(species_site.binding, [\"unbind\", \"unbound\", \"bind\", \"bound\"])) && species_site.binding !== \"\") {\n\t\t\t\t\t\tconsole.log(`Species ${species_type.id}: invalid binding parameter ${species_site.binding}`);\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t\tinvalid_found = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (invalid_found) continue;\n\t\t\t\t// allow wildcard matches, all bind sites/states must be filled in species info\n\t\t\t\tif (!match_species(species_type, annotspecies_bindings_list, true)) {\n\t\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet products = list_products[\"annotation\"][\"cell4d:speciesReference\"];\n\t\tif (!Array.isArray(products)) products = [products];\n\t\tfor (let product of products) {\n\t\t\tif (!product[\"cell4d:listOfSpeciesTypes\"]) {\n\t\t\t\tconsole.log(\"list of products in reaction \" + reaction_id + \" missing species list.\")\n\t\t\t}\n\t\t\tlet species_types: Array<any> = product[\"cell4d:listOfSpeciesTypes\"][\"cell4d:speciesType\"];\n\t\t\tif (!Array.isArray(species_types)) species_types = [species_types];\n\t\t\tfor (let species_type of species_types) {\n\t\t\t\tif (!species_type.id) {\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet species_sites = species_type[\"cell4d:bindingSite\"];\n\t\t\t\tif (!species_sites) species_sites = [];\n\t\t\t\t// there is a difference between bind sites and mod sites. only 1 of state and binding should be filled\n\t\t\t\tlet invalid_found = false;\n\t\t\t\tfor (let species_site of species_sites) {\n\t\t\t\t\t// state XOR binding filled\n\t\t\t\t\tif (!(species_site.state === \"\") ? !(species_site.binding === \"\") : (species_site.binding === \"\")) {\n\t\t\t\t\t\tconsole.log(`Species ${species_type.id}: only 1 of state or binding site should be filled`);\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t\tinvalid_found = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(is_correct_string(species_site.binding, [\"unbind\", \"unbound\", \"bind\", \"bound\"])) && species_site.binding !== \"\") {\n\t\t\t\t\t\tconsole.log(`Species ${species_type.id}: invalid binding parameter ${species_site.binding}`);\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t\tinvalid_found = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (invalid_found) continue;\n\t\t\t\t// allow wildcard matches, all bind sites/states must be filled in species info\n\t\t\t\tif (!match_species(species_type, annotspecies_bindings_list, true)) {\n\t\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// products can have optional active transport field\n\t\t\tif (products[\"cell4d:activeTransport\"]) {\n\t\t\t\tif (products[\"cell4d:activeTransport\"].destination) {\n\t\t\t\t\tif (!compart_list.includes(products[\"cell4d:activeTransport\"].destination)) {\n\t\t\t\t\t\tconsole.log(\"destination compartment \" + products[\"cell4d:activeTransport\"].destination +\n\t\t\t\t\t\t\t\" of reaction \" + reaction_id + \" does not exist.\");\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"destination of transport of product in \" + reaction_id + \" must be in 'destination' attribute\")\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// deal with modifier field\n\t\tif (list_modifiers[\"annotation\"][\"cell4d:speciesReference\"].length > 1) {\n\t\t\tconsole.log(\"There should only be one 'modifier' in reaction \" + reaction_id)\n\t\t\toutput.errors.push(possible_errors[1]);\n\t\t}\n\t\tlet modifier = list_modifiers[\"annotation\"][\"cell4d:speciesReference\"][0];\n\t\tlet is_enzymatic = false;\n\t\tif (modifier[\"cell4d:listOfSpeciesTypes\"][\"cell4d:speciesType\"].length === 1) {\n\t\t\tlet modifier_species = modifier[\"cell4d:listOfSpeciesTypes\"][\"cell4d:speciesType\"][0].id;\n\t\t\tif (modifier_species != \"empty\") {\n\t\t\t\tis_enzymatic = true;\n\t\t\t\tif (metabolite_list.includes(modifier_species)) {\n\t\t\t\t\tconsole.log(`modifier species ${modifier_species} cannot be a bulk molecule.`)\n\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t} else if (!annotspecies_bindings_list.find((species: { id: any; }) => species.id === modifier_species)) {\n\t\t\t\t\tconsole.log(`modifier species ${modifier_species} does not exist.`)\n\t\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// kinetics\n\t\tlet parameters = reaction?.[\"kineticLaw\"]?.[\"listOfParameters\"]?.[\"parameter\"];\n\t\tif (!parameters) {\n\t\t\tconsole.log(`Reaction ${reaction_id} missing kinetic fields`)\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t}\n\t\tlet list_of_params_normal = [\"Kforward\", \"Kreverse\", \"radius\"];\n\t\tlet list_of_params_enzmatic = [\"Ka\", \"Kp\", \"Keq\", \"Vm\"];\n\n\t\tlet param_names: Array<string> = parameters.map((param: { name: string; }) => param.name)\n\t\tif (is_enzymatic) {\n\t\t\t// check both ways\n\t\t\tif (!list_of_params_enzmatic.every((l_param: string) => is_correct_string(l_param, param_names)) ||\n\t\t\t\t!param_names.every((param: string) => is_correct_string(param, list_of_params_enzmatic))) {\n\t\t\t\tconsole.log(`Enzymatic reactions have four reaction parameters \"Ka\", \"Kp\", \"Keq\", \"Vm\"`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!param_names.every((param: string) => is_correct_string(param, list_of_params_normal))) {\n\t\t\t\tconsole.log(`Reaction parameters are valid if \"Kforward\", \"Kreverse\", \"radius\"`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t}\n\t\tObject.values(parameters).forEach(function (param: any) {\n\t\t\tif (!param.name) {\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t}\n\t\t\tif (!param.value) {\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t} else if (!is_in_range(param.value, [0, Infinity])) {\n\t\t\t\tconsole.log(`Reaction ${reaction_id} parameter values must be a positive value.`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t})\n\t})\n\tif (output.errors.length !== 0) output.pass = false;\n\treturn (output);\n}\n\n// match a given species info with description in annot species. optional wildcard parameter allows\n// wobbly matching of states (all species sites must be in annot but not vice versa)\nlet match_species = function (species_type: any, annotspecies_bindings_list: any, wildcard = false): boolean {\n\tlet id = species_type.id;\n\tlet species_sites = species_type[\"cell4d:bindingSite\"];\n\tif (!species_sites) species_sites = [];\n\tif (!Array.isArray(species_sites)) species_sites = [species_sites];\n\n\tif (!annotspecies_bindings_list.find((species: { id: any; }) => species.id === id)) {\n\t\treturn false;\n\t}\n\tlet annot_bindings = annotspecies_bindings_list.find((species: { id: any; }) => species.id === id).sites;\n\tlet matching = false;\n\t// check for equality between binding list blueprint annot and species type binding list\n\tlet list_of_species_sites = species_sites.map((site: { id: any; }) => {\n\t\tif (!site) return null;\n\t\treturn site.id;\n\t})\n\tlet list_of_annot_sites = annot_bindings.map((site: { id: any; }) => {\n\t\tif (!site) return null;\n\t\treturn site.id;\n\t})\n\t// try to match the state of binding site to one of possible states described in annot\n\tlet state_match = true;\n\tfor (let species_site of species_sites) {\n\t\tif (species_site.state) {\n\t\t\tlet found = false;\n\t\t\tfor (let annot_site of annot_bindings) {\n\t\t\t\tif (annot_site.states && species_site.id === annot_site.id) {\n\t\t\t\t\tif (annot_site.states.includes(species_site.state)) found = true;\n\t\t\t\t}\n\t\t\t\tif (found) break;\n\t\t\t}\n\t\t\tif (!found) state_match = false;\n\t\t} else {\n\t\t\tlet matched_site = annot_bindings.find((site: { id: any; }) => site.id === species_site.id);\n\t\t\tif (!matched_site) {\n\t\t\t\tstate_match = false;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (matched_site.states) {\n\t\t\t\t\tstate_match = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (state_match) {\n\t\tif (list_of_species_sites.every((site: string) => list_of_annot_sites.includes(site))) {\n\t\t\tmatching = true;\n\t\t}\n\t}\n\n\tif ((annot_bindings.length !== species_sites.length) && !wildcard) {\n\t\tmatching = false;\n\t\tconsole.log(\"Species \" + id + \": all binding site info must be filled\");\n\t}\n\n\tif (!matching) {\n\t\tconsole.log(\"Species \" + id + \" has mismatched binding site with annotation info\");\n\t}\n\treturn (matching);\n}\n\nlet validate_events = function (events_model: any, compart_list: Array<string>, species_list: Array<string>): { pass: boolean; errors: Array<string>; } {\n\tlet output = { pass: true, errors: Array<string>() }\n\tlet possible_errors = [\"missing_var\", \"invalid_var\", \"no_match\"];\n\tlet event_name_list: Array<string> = events_model.map((event: { name: string; }) => {\n\t\treturn event.name;\n\t})\n\tObject.values(events_model).forEach(function (event: any) {\n\t\tif (!(event.name && event.type && event.trigger && event.probability)) {\n\t\t\tconsole.log(`Not all attributes of event are filled`)\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\treturn;\n\t\t}\n\t\tlet possible_event_types = [\"add_mols\", \"remove_mols\", \"transport_mols\"];\n\t\tlet possible_event_triggers = [\"time\", \"state\", \"event\"];\n\t\tlet location_keywords = [\"xloc\", \"yloc\", \"zloc\", \"xloc_1\", \"xloc_2\", \"yloc_1\", \"yloc_2\", \"zloc_1\", \"zloc_2\"];\n\t\tif (!is_correct_string(event.type, possible_event_types)) {\n\t\t\tconsole.log(`Event ${event.name} has invalid event type ${event.type}`)\n\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\treturn;\n\t\t}\n\t\tif (!is_correct_string(event.trigger, possible_event_triggers)) {\n\t\t\tconsole.log(`Event ${event.name} has invalid event type ${event.trigger}`)\n\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\treturn;\n\t\t}\n\t\tif (isNaN(Number(event.probability)) || (event.probability > 1 || event.probability < 0)) {\n\t\t\tconsole.log(`Event ${event.name} probability must be 0 < x < 1, but is \"${event.probability}\"`)\n\t\t\toutput.errors.push(possible_errors[1]);\n\t\t}\n\n\t\tif (!event[event.type]) {\n\t\t\tconsole.log(`Event ${event.name} missing ${event.type} element`);\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\treturn;\n\t\t}\n\t\tif (!event[event.type].id || !event[event.type].amount) {\n\t\t\tconsole.log(`Event ${event.name} element ${event.type} must have 'id' and 'amount' attributes`);\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t}\n\t\tif (!species_list.includes(event[event.type].id)) {\n\t\t\tconsole.log(`Event ${event.name} ${event.type} 'id' attribute must be a valid species`);\n\t\t\toutput.errors.push(possible_errors[2]);\n\t\t}\n\t\tif (!isPositiveInt(event[event.type].amount)) {\n\t\t\tconsole.log(`Event ${event.name} element ${event.type} 'amount' attribute must be a positive integer`);\n\t\t\toutput.errors.push(possible_errors[1]);\n\t\t}\n\t\tif (!event[\"location\"]) {\n\t\t\tconsole.log(`Event ${event.name} must have 'location' element`);\n\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\treturn;\n\t\t} else if (Object.keys(event[\"location\"]).length === 1) {\n\t\t\tif (!event[\"location\"].compartment) {\n\t\t\t\tconsole.log(`Event ${event.name} 'location' element must have 'compartment' attribute`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t} else if (!compart_list.includes(event[\"location\"].compartment)) {\n\t\t\t\tconsole.log(`Event ${event.name} compartment must be a valid compartment from listOfCompartments`)\n\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t}\n\t\t} else {\n\t\t\tlet coords_valid = true;\n\t\t\tif (Object.keys(event[\"location\"]).length === 3) {\n\t\t\t\tif (!location_keywords.slice(0, 3).every(word => Object.keys(event[\"location\"]).includes(word))) {\n\t\t\t\t\tconsole.log(`Event ${event.name} destination coordinates must be ${location_keywords.slice(0, 3)}`)\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\tcoords_valid = false;\n\t\t\t\t}\n\t\t\t} else if (Object.keys(event[\"location\"]).length === 6) {\n\t\t\t\tif (!location_keywords.slice(3, 9).every(word => Object.keys(event[\"location\"]).includes(word))) {\n\t\t\t\t\tconsole.log(`Event ${event.name} location coordinate range must be ${location_keywords.slice(3, 9)}`)\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\tcoords_valid = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(`Event ${event.name} 'location' element must have valid location information.`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\tcoords_valid = false;\n\t\t\t}\n\t\t\tif (coords_valid) {\n\t\t\t\tfor (let coord of Object.keys(event[\"location\"])) {\n\t\t\t\t\tif (!isPositiveInt(event[\"location\"][coord])) {\n\t\t\t\t\t\tconsole.log(`Event ${event.name} 'location' element ${coord} must be a positive integer`);\n\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (event.type === \"transport_mols\") {\n\t\t\tif (!event[\"transport_destination\"]) {\n\t\t\t\tconsole.log(`Event ${event.name} must have 'transport_destination' element`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t} else if (Object.keys(event[\"transport_destination\"]).length === 1) {\n\t\t\t\tif (!event[\"transport_destination\"].compartment) {\n\t\t\t\t\tconsole.log(`Event ${event.name} 'transport_destination' element must have 'compartment' attribute`);\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t} else if (!compart_list.includes(event[\"transport_destination\"].compartment)) {\n\t\t\t\t\tconsole.log(`Event ${event.name} destination must be a valid compartment from listOfCompartments`)\n\t\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet coords_valid = true;\n\t\t\t\tif (Object.keys(event[\"transport_destination\"]).length === 3) {\n\t\t\t\t\tif (!location_keywords.slice(0, 3).every(word => Object.keys(event[\"transport_destination\"]).includes(word))) {\n\t\t\t\t\t\tconsole.log(`Event ${event.name} destination coordinates must be ${location_keywords.slice(0, 3)}`)\n\t\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\t\tcoords_valid = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (Object.keys(event[\"transport_destination\"]).length === 6) {\n\t\t\t\t\tif (!location_keywords.slice(3, 9).every(word => Object.keys(event[\"transport_destination\"]).includes(word))) {\n\t\t\t\t\t\tconsole.log(`Event ${event.name} destination coordinate range must be ${location_keywords.slice(3, 9)}`)\n\t\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\t\tcoords_valid = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(`Event ${event.name} 'transport_destination' element must have destination information.`);\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\tcoords_valid = false;\n\t\t\t\t}\n\t\t\t\tif (coords_valid) {\n\t\t\t\t\tfor (let coord of Object.keys(event[\"transport_destination\"])) {\n\t\t\t\t\t\tif (!isPositiveInt(event[\"transport_destination\"][coord])) {\n\t\t\t\t\t\t\tconsole.log(`Event ${event.name} 'transport_destination' element ${coord} must be a positive integer`);\n\t\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (event.trigger === \"time\") {\n\t\t\tif (!event[\"time_trigger\"]) {\n\t\t\t\tconsole.log(`Event ${event.name} must have 'time_trigger' element`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!event[\"time_trigger\"].repeat || !event[\"time_trigger\"].interval || !event[\"time_trigger\"].initial) {\n\t\t\t\tconsole.log(`Event ${event.name} 'time_trigger' element must have 'repeat' 'interval' 'initial' attributes`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!is_correct_string(event[\"time_trigger\"].repeat, [\"true\", \"false\"])) {\n\t\t\t\tconsole.log(`Event ${event.name} 'repeat' attribute must be true or false`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t\tif (!isPositiveInt(event[\"time_trigger\"].interval)) {\n\t\t\t\tconsole.log(`Event ${event.name} 'interval' attribute must be a positive integer`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t\tif (!isPositiveInt(event[\"time_trigger\"].initial)) {\n\t\t\t\tconsole.log(`Event ${event.name} 'initial' attribute must be a positive integer`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t} else if (event.trigger === \"state\") {\n\t\t\tif (!event[\"state_trigger\"]) {\n\t\t\t\tconsole.log(`Event ${event.name} must have 'state_trigger' element`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!event[\"state_trigger\"].repeat || !event[\"state_trigger\"].condition || !event[\"state_trigger\"].id ||\n\t\t\t\t!event[\"state_trigger\"].amount || !event[\"state_trigger\"].interval) {\n\t\t\t\tconsole.log(`Event ${event.name} 'state_trigger' must have 'repeat' 'condition' 'id' 'amount' 'interval' attributes`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!is_correct_string(event[\"state_trigger\"].repeat, [\"true\", \"false\"])) {\n\t\t\t\tconsole.log(`Event ${event.name} 'repeat' attribute must be 'true' or 'false'`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t\tif (!is_correct_string(event[\"state_trigger\"].condition, [\"less_than\", \"greater_than\"])) {\n\t\t\t\tconsole.log(`Event ${event.name} 'condition' attribute must be 'less_than' or 'greater_than'`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t\tif (!species_list.includes(event[\"state_trigger\"].id)) {\n\t\t\t\tconsole.log(`Event ${event.name} trigger species 'id' must be a valid species from listOfSpecies`)\n\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t}\n\t\t\tif (!isPositiveInt(event[\"state_trigger\"].interval)) {\n\t\t\t\tconsole.log(`Event ${event.name} 'interval' attribute must be a positive integer`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\t\t\tif (!isPositiveInt(event[\"state_trigger\"].amount)) {\n\t\t\t\tconsole.log(`Event ${event.name} 'amount' attribute must be a positive integer`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\n\t\t\tif (!event[\"state_trigger_loc\"]) {\n\t\t\t\tconsole.log(`Event ${event.name} must have 'state_trigger_loc' element`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t} else if (Object.keys(event[\"state_trigger_loc\"]).length === 1) {\n\t\t\t\tif (!event[\"state_trigger_loc\"].compartment) {\n\t\t\t\t\tconsole.log(`Event ${event.name} 'state_trigger_loc' element must have 'compartment' attribute`);\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t} else if (!compart_list.includes(event[\"state_trigger_loc\"].compartment)) {\n\t\t\t\t\tconsole.log(`Event ${event.name} trigger location must be a valid compartment from listOfCompartments`)\n\t\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet coords_valid = true;\n\t\t\t\tif (Object.keys(event[\"state_trigger_loc\"]).length === 3) {\n\t\t\t\t\tif (!location_keywords.slice(0, 3).every(word => Object.keys(event[\"state_trigger_loc\"]).includes(word))) {\n\t\t\t\t\t\tconsole.log(`Event ${event.name} destination coordinates must be ${location_keywords.slice(0, 3)}`)\n\t\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\t\tcoords_valid = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (Object.keys(event[\"state_trigger_loc\"]).length === 6) {\n\t\t\t\t\tif (!location_keywords.slice(3, 9).every(word => Object.keys(event[\"state_trigger_loc\"]).includes(word))) {\n\t\t\t\t\t\tconsole.log(`Event ${event.name} destination coordinate range must be ${location_keywords.slice(3, 9)}`)\n\t\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\t\tcoords_valid = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(`Event ${event.name} 'state_trigger_loc' element must have compartment information.`);\n\t\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\t\tcoords_valid = false;\n\t\t\t\t}\n\t\t\t\tif (coords_valid) {\n\t\t\t\t\tfor (let coord of Object.keys(event[\"state_trigger_loc\"])) {\n\t\t\t\t\t\tif (!isPositiveInt(event[\"state_trigger_loc\"][coord])) {\n\t\t\t\t\t\t\tconsole.log(`Event ${event.name} 'state_trigger_loc' element ${coord} must be a positive integer`);\n\t\t\t\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (event.trigger === \"event\") {\n\t\t\tif (!event[\"event_trigger\"]) {\n\t\t\t\tconsole.log(`Event ${event.name} must have 'state_trigger' element`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!event[\"event_trigger\"].name || !event[\"event_trigger\"].delay) {\n\t\t\t\tconsole.log(`Event ${event.name} 'event_trigger' element must have 'name' 'delay' attributes`);\n\t\t\t\toutput.errors.push(possible_errors[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!event_name_list.includes(event[\"event_trigger\"].name)) {\n\t\t\t\tconsole.log(`Event ${event.name} triggering event does not exist`);\n\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t} else if (event[\"event_trigger\"].name === event.name) {\n\t\t\t\tconsole.log(`Event ${event.name} triggering event cannot be itself`);\n\t\t\t\toutput.errors.push(possible_errors[2]);\n\t\t\t}\n\t\t\tif (!isPositiveInt(event[\"event_trigger\"].delay)) {\n\t\t\t\tconsole.log(`Event ${event.name} triggering event timestep delay must be a positive integer`);\n\t\t\t\toutput.errors.push(possible_errors[1]);\n\t\t\t}\n\n\t\t}\n\n\t})\n\tif (output.errors.length !== 0) output.pass = false;\n\treturn (output);\n}\n\n\nlet validate_model = function (xml_obj: any): any {\n\tlet output = {\n\t\tpass: true,\n\t\terrors: {\n\t\t\tgeneral: Array<string>(),\n\t\t\tenv_var: Array<string>(),\n\t\t\tannot_species: Array<string>(),\n\t\t\tcompartment: Array<string>(),\n\t\t\tspecies: Array<string>(),\n\t\t\treactions: Array<string>(),\n\t\t\tevents: Array<string>(),\n\t\t},\n\t\tlongErrors: {\n\t\t\tgeneral: Array<string>(),\n\t\t\tenv_var: Array<string>(),\n\t\t\tannot_species: Array<string>(),\n\t\t\tcompartment: Array<string>(),\n\t\t\tspecies: Array<string>(),\n\t\t\treactions: Array<string>(),\n\t\t\tevents: Array<string>(),\n\t\t}\n\t}\n\n\tlet error = false;\n\t// validate sbml -> model levels\n\tif (!xml_obj[\"sbml\"][\"model\"]) {\n\t\tconsole.log(\"top level must be 'sbml' followed by 'model'\");\n\t\terror = true;\n\t}\n\tlet xml_model = xml_obj[\"sbml\"][\"model\"];\n\n\t// ensure all mandatory groups are there. Environmental variables, compartments\n\tlet env_var = false;\n\tlet annot_species = false;\n\tlet compart = false;\n\tlet species = false;\n\tlet reactions = false;\n\tlet events = false;\n\tif (xml_model?.[\"annotation\"]?.[\"cell4d:environmentVariables\"]) {\n\t\tenv_var = true;\n\t}\n\tif (xml_model?.[\"listOfCompartments\"]?.[\"compartment\"] !== undefined) {\n\t\tcompart = true;\n\t}\n\tif (xml_model?.[\"annotation\"]?.[\"cell4d:listOfAnnotationSpeciesTypes\"]?.[\"cell4d:speciesType\"] !== undefined) {\n\t\tannot_species = true;\n\t}\n\tif (xml_model?.[\"listOfSpecies\"]?.[\"species\"] !== undefined) {\n\t\tspecies = true;\n\t}\n\tif (xml_model?.[\"listOfReactions\"]?.[\"reaction\"] !== undefined) {\n\t\treactions = true;\n\t}\n\tif (xml_model?.[\"annotation\"]?.[\"cell4d:events\"]?.[\"event\"] !== undefined) {\n\t\tevents = true;\n\t}\n\n\t// dependencies between groups: events and reactions are optional.\n\tlet possible_general_errors = [\"missing_env_var\", \"missing_annot_species\", \"missing_compartment\", \"missing_species\"];\n\tif (!env_var) {\n\t\toutput.errors.general.push(possible_general_errors[0]);\n\t}\n\tif (species) {\n\t\tif (!annot_species) output.errors.general.push(possible_general_errors[1]);\n\t}\n\tif (!compart) {\n\t\toutput.errors.general.push(possible_general_errors[2]);\n\t}\n\tif (events || reactions) {\n\t\tif (!species) output.errors.general.push(possible_general_errors[3]);\n\t}\n\t// if any general errors exist, stop\n\tif (output.errors.general.length > 0) {\n\t\toutput.pass = false;\n\t\treturn (output);\n\t}\n\n\tconst schemas = schema;\n\n\t// validate env variables\n\tlet env_model = xml_model[\"annotation\"][\"cell4d:environmentVariables\"];\n\tlet check_env = validate_env(env_model, schemas.envVar);\n\t// if (!check_env.pass) {\n\t// \toutput.errors.env_var = check_env.errors.slice();\n\t// \toutput.pass = false;\n\t// }\n\n\t// validate compartments\n\tlet compart_model = xml_model[\"listOfCompartments\"];\n\tlet compart_list: Array<string> = compart_model.compartment.map((compart: { id: any; }) => { return compart.id })\n\tlet check_compart = validate_comparts(compart_model, schemas.compart);\n\t// if (!check_compart.pass) {\n\t// \toutput.errors.compartment = check_compart.errors.slice();\n\t// \toutput.pass = false;\n\t// }\n\n\t// validate annotation species\n\tlet metabolite_list: Array<string> = [];\n\tlet annotspecies_bindings_list: Array<{ id: string, sites: any }> = [];\n\tif (annot_species) {\n\t\tlet annotspecies_model = xml_model[\"annotation\"][\"cell4d:listOfAnnotationSpeciesTypes\"][\"cell4d:speciesType\"];\n\t\t// if (!Array.isArray(annotspecies_model)) annotspecies_model = [annotspecies_model];\n\n\t\tlet metabolites = annotspecies_model.filter((species: { speciesMoleculeType: string; id: any; }) => {\n\t\t\tif (species.speciesMoleculeType === \"SIMPLE_MOLECULE\") {\n\t\t\t\treturn (species.id)\n\t\t\t}\n\t\t});\n\t\tmetabolite_list = metabolites.map((metab: any) => {\n\t\t\treturn metab.id;\n\t\t})\n\t\tannotspecies_bindings_list = annotspecies_model.map((annotspecies: any) => {\n\t\t\tlet species_id = annotspecies.id;\n\t\t\tif (!annotspecies[\"cell4d:listOfBindingSites\"]) {\n\t\t\t\treturn { id: species_id, sites: [] }\n\t\t\t}\n\t\t\tlet sites = annotspecies[\"cell4d:listOfBindingSites\"][\"cell4d:bindingSite\"]\n\t\t\tObject.values(sites).forEach(function (site: any) {\n\t\t\t\tif (site[\"cell4d:listOfPossibleStates\"]) {\n\t\t\t\t\tif (site[\"cell4d:listOfPossibleStates\"][\"cell4d:state\"]) {\n\t\t\t\t\t\tsite.states = site[\"cell4d:listOfPossibleStates\"][\"cell4d:state\"].map((state: { value: any; }) => { return state.value });\n\t\t\t\t\t\tdelete site[\"cell4d:listOfPossibleStates\"];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn { id: species_id, sites: sites }\n\t\t})\n\t\tlet annotspecies_model_long = xml_model[\"annotation\"][\"cell4d:listOfAnnotationSpeciesTypes\"];\n\n\t\tlet check_annotspecies = validate_annot_species(annotspecies_model_long, compart_list, schema.annotSpecies);\n\t\t// if (!check_annotspecies.pass) {\n\t\t// \toutput.errors.annot_species = check_annotspecies.errors.slice();\n\t\t// \toutput.pass = false;\n\t\t// }\n\t}\n\n\t// validate list of species\n\tlet species_list: Array<string> = [];\n\tif (species) {\n\t\tlet species_model = xml_model[\"listOfSpecies\"][\"species\"];\n\t\tspecies_list = species_model.map((species: { id: any; }) => { return species.id });\n\t\tlet check_species = validate_species(species_model, compart_list, annotspecies_bindings_list);\n\t\tif (!check_species.pass) {\n\t\t\toutput.errors.species = check_species.errors.slice();\n\t\t\toutput.pass = false;\n\t\t}\n\t}\n\n\t// validate list of reactions\n\tlet check_reactions;\n\tif (reactions) {\n\t\tlet reactions_model = xml_model[\"listOfReactions\"][\"reaction\"];\n\t\tcheck_reactions = validate_reactions(reactions_model, compart_list, annotspecies_bindings_list, metabolite_list);\n\t\tif (!check_reactions.pass) {\n\t\t\toutput.errors.reactions = check_reactions.errors.slice();\n\t\t\toutput.pass = false;\n\t\t}\n\t}\n\n\t// validate list of events\n\tlet check_events;\n\tif (events) {\n\t\tlet events_model = xml_model[\"annotation\"][\"cell4d:events\"][\"event\"];\n\t\tcheck_events = validate_events(events_model, compart_list, species_list);\n\t\tif (!check_events.pass) {\n\t\t\toutput.errors.events = check_events.errors.slice();\n\t\t\toutput.pass = false;\n\t\t}\n\t}\n\n\t// if ((output.pass)) {\n\t// \tconsole.log(\"xml model is well-formed.\")\n\t// }\n\treturn (output);\n};\n\nexport let validate_xml = function (xml_file: string, raw_string = false): any {\n\tlet validation_result = {\n\t\tpass: true,\n\t\terrors: {\n\t\t\tgeneral: Array<string>(),\n\t\t\tenv_var: Array<string>(),\n\t\t\tannot_species: Array<string>(),\n\t\t\tcompartment: Array<string>(),\n\t\t\tspecies: Array<string>(),\n\t\t\treactions: Array<string>(),\n\t\t\tevents: Array<string>(),\n\t\t},\n\t\tlongErrors: {\n\t\t\tgeneral: Array<validationError>(),\n\t\t\tenv_var: Array<validationError>(),\n\t\t\tannot_species: Array<validationError>(),\n\t\t\tcompartment: Array<validationError>(),\n\t\t\tspecies: Array<validationError>(),\n\t\t\treactions: Array<validationError>(),\n\t\t\tevents: Array<validationError>(),\n\t\t},\n\t\tjson: {}\n\t}\n\n\t// allow raw string as input for this function, or a file path. default is file path\n\tvar xml_string;\n\tif (raw_string) {\n\t\txml_string = xml_file;\n\t} else {\n\t\ttry {\n\t\t\txml_string = fs.readFileSync(xml_file, \"utf-8\");\n\t\t} catch (err) {\n\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\tconsole.error(`File ${xml_file} not found.`)\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// list of nodes that should always be arrays when doing the xml -> json conversion\n\tlet arrayNotation = [\n\t\t'cell4d:speciesType', 'cell4d:latticePointDefinition', 'cell4d:compartment',\n\t\t'cell4d:bindingSite', 'cell4d:state',\n\t\t'event',\n\t\t'compartment', 'cell4d:latticePointDefinition',\n\t\t'species', 'cell4d:speciesType', 'cell4d:bindingSite',\n\t\t'reaction', 'cell4d:speciesReference', 'parameter',\n\t];\n\tlet json_obj;\n\ttry {\n\t\tconst json_string = xmlParser.xml2json(xml_string, {\n\t\t\tcompact: true,\n\t\t\talwaysArray: arrayNotation,\n\t\t});\n\t\tjson_obj = JSON.parse(json_string);\n\t} catch (err) {\n\t\tvalidation_result.pass = false;\n\t\tvalidation_result.errors.general = [\"File read failed.\"];\n\t\treturn;\n\t}\n\n\n\t// ensure all mandatory groups are there. Environmental variables, compartments\n\tlet env_var = false;\n\tlet annot_species = false;\n\tlet compart = false;\n\tlet species = false;\n\tlet reactions = false;\n\tlet events = false;\n\tif (json_obj?.sbml?.model?.[\"annotation\"]?.[\"cell4d:environmentVariables\"]) {\n\t\tenv_var = true;\n\t}\n\tif (json_obj?.sbml?.model?.[\"listOfCompartments\"]?.[\"compartment\"] !== undefined) {\n\t\tcompart = true;\n\t}\n\tif (json_obj?.sbml?.model?.[\"annotation\"]?.[\"cell4d:listOfAnnotationSpeciesTypes\"]?.[\"cell4d:speciesType\"] !== undefined) {\n\t\tannot_species = true;\n\t}\n\tif (json_obj?.sbml?.model?.[\"listOfSpecies\"]?.[\"species\"] !== undefined) {\n\t\tspecies = true;\n\t}\n\tif (json_obj?.sbml?.model?.[\"listOfReactions\"]?.[\"reaction\"] !== undefined) {\n\t\treactions = true;\n\t}\n\tif (json_obj?.sbml?.model?.[\"annotation\"]?.[\"cell4d:events\"]?.[\"event\"] !== undefined) {\n\t\tevents = true;\n\t}\n\n\t// dependencies between groups: events and reactions are optional.\n\tlet possible_general_errors = [\"missing_env_var\", \"missing_annot_species\", \"missing_compartment\", \"missing_species\"];\n\tif (!env_var) {\n\t\tvalidation_result.errors.general.push(possible_general_errors[0]);\n\t}\n\tif (species) {\n\t\tif (!annot_species) validation_result.errors.general.push(possible_general_errors[1]);\n\t}\n\tif (!compart) {\n\t\tvalidation_result.errors.general.push(possible_general_errors[2]);\n\t}\n\tif (events || reactions) {\n\t\tif (!species) validation_result.errors.general.push(possible_general_errors[3]);\n\t}\n\t// if any general errors exist, stop\n\tif (validation_result.errors.general.length > 0) {\n\t\tvalidation_result.pass = false;\n\t\treturn (validation_result);\n\t}\n\n\n\n\tlet jsonEnv = json_obj?.sbml?.model?.annotation?.[\"cell4d:environmentVariables\"];\n\tlet jsonComparts = json_obj?.sbml?.model?.listOfCompartments;\n\tlet jsonAnnotSpecies = json_obj?.sbml?.model?.annotation?.[\"cell4d:listOfAnnotationSpeciesTypes\"];\n\tlet validEnv = validate_env(jsonEnv, schema.envVar);\n\tvalidation_result.errors.env_var = validEnv.errors.slice();\n\n\tlet validComparts = validate_comparts(jsonComparts, schema.compart);\n\tvalidation_result.errors.compartment = validComparts.errors.slice();\n\n\t// Early termination if the mandatory sections have errors\n\tif (!validComparts.pass || !validEnv.pass) {\n\t\tvalidation_result.pass = false;\n\t\treturn (validation_result)\n\t}\n\tlet compart_list: Array<string> = jsonComparts.compartment.map((compart: { _attributes: { id: string; } }) => { return compart._attributes.id })\n\n\tlet annotSpecies_list: Array<{ id: string, sites: Array<{ id: string, state: Array<string> }> }>;\n\tif (jsonAnnotSpecies) {\n\t\tlet validAnnotSpecies = validate_annot_species(jsonAnnotSpecies, compart_list, schema.annotSpecies);\n\t\tvalidation_result.errors.annot_species = validAnnotSpecies.errors.slice();\n\n\t\t// Early \n\t\tif (!validAnnotSpecies.pass) {\n\t\t\tvalidation_result.pass = false;\n\t\t\treturn (validation_result)\n\t\t}\n\n\t\t// dig into the deeply nested binding sites info, simplify structure for validation downstream\n\t\t// {\n\t\t// \tid: string, \n\t\t// \tsites: Array<{\n\t\t// \t\tid: string, \n\t\t// \t\tstate: Array<string>\n\t\t// \t}>\n\t\t// }\n\t\tannotSpecies_list = jsonAnnotSpecies[\"cell4d:speciesType\"].map((annotSpecies: any) => {\n\t\t\tlet id: string = annotSpecies._attributes.id;\n\t\t\tlet sites: Array<{ id: string, states: Array<string> }>;\n\n\t\t\tlet bindingSites_obj: Array<any> = annotSpecies?.[\"cell4d:listOfBindingSites\"]?.[\"cell4d:bindingSite\"]\n\t\t\tif (!bindingSites_obj) {\n\t\t\t\tsites = [];\n\t\t\t} else {\n\t\t\t\tsites = bindingSites_obj.map((site: any) => {\n\t\t\t\t\tlet site_id = site._attributes.id;\n\t\t\t\t\tlet states_obj: Array<any> = site?.[\"cell4d:listOfPossibleStates\"]?.[\"cell4d:state\"];\n\t\t\t\t\tlet states: Array<string> = [];\n\t\t\t\t\tif (!states_obj) {\n\t\t\t\t\t\tstates = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstates = states_obj.map((state: any) => {\n\t\t\t\t\t\t\treturn state._attributes.value;\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\treturn ({\n\t\t\t\t\t\tid: site_id,\n\t\t\t\t\t\tstates: states,\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn ({ id: id, sites: sites });\n\t\t})\n\n\t}\n\n\n\tconst reversed = xmlParser.js2xml(json_obj, {\n\t\tcompact: true,\n\n\t});\n\t// testing reversibility, istrue\n\t// console.log(reversed);\n\n\t// disable for now until all validation functions refactored\n\t// let valid = validate_model(xml_object);\n\n\t// return (valid);\n\tif (validation_result.pass) {\n\t\tvalidation_result.json = json_obj;\n\t}\n\treturn (validation_result);\n}\n\nlet test = validate_xml(\"./tests/annot_species/metab_binding.xml\");\n// let test = validate_xml(\"tests/annot_species/wrong_binding.xml\");\n\n// let test = validate_xml(\"tests/comparts/missing_id.xml\");\n// let test = validate_xml(\"./test.xml\");\n\n// fs.writeFileSync(\"test_out.xml\", test2);\n\nconsole.log();\n","/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/FormComparts/FormComparts.tsx",[],"/mnt/c/Users/Donny/Documents/cell4d-react/src/TabComponent/TabComponent.tsx",["96"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/App.tsx",["97"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/index.tsx",["98"],"import React from 'react';\nimport ReactDOM from 'react-dom';\n// import 'react-tabs/style/react-tabs.css';\nimport './index.css';\nimport App from './App';\n\nimport { render } from '@testing-library/react';\n// import reportWebVitals from './reportWebVitals';\n\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>\n\t,\n\tdocument.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n",["99","100"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/optional.ts",[],["101","102"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/FormAnnot/FormAnnot.tsx",["103","104","105"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/formInitialState.ts",[],"/mnt/c/Users/Donny/Documents/cell4d-react/src/VisualizeModel/VisualizeModel.tsx",["106"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/colorPicker.tsx",[],"/mnt/c/Users/Donny/Documents/cell4d-react/src/modelContext.ts",[],"/mnt/c/Users/Donny/Documents/cell4d-react/src/Forms/FormSpecies/FormSpecies.tsx",["107","108","109","110"],"/mnt/c/Users/Donny/Documents/cell4d-react/src/types.ts",[],{"ruleId":"111","severity":1,"message":"112","line":56,"column":6,"nodeType":"113","messageId":"114","endLine":56,"endColumn":29},{"ruleId":"111","severity":1,"message":"115","line":189,"column":8,"nodeType":"113","messageId":"114","endLine":189,"endColumn":26},{"ruleId":"111","severity":1,"message":"116","line":9,"column":10,"nodeType":"113","messageId":"114","endLine":9,"endColumn":22},{"ruleId":"111","severity":1,"message":"117","line":9,"column":24,"nodeType":"113","messageId":"114","endLine":9,"endColumn":31},{"ruleId":"111","severity":1,"message":"118","line":63,"column":7,"nodeType":"113","messageId":"114","endLine":63,"endColumn":18},{"ruleId":"111","severity":1,"message":"119","line":75,"column":8,"nodeType":"113","messageId":"114","endLine":75,"endColumn":20},{"ruleId":"120","severity":1,"message":"121","line":75,"column":145,"nodeType":"122","messageId":"123","endLine":75,"endColumn":147},{"ruleId":"111","severity":1,"message":"124","line":76,"column":9,"nodeType":"113","messageId":"114","endLine":76,"endColumn":19},{"ruleId":"111","severity":1,"message":"125","line":2,"column":15,"nodeType":"113","messageId":"114","endLine":2,"endColumn":18},{"ruleId":"111","severity":1,"message":"126","line":3,"column":13,"nodeType":"113","messageId":"114","endLine":3,"endColumn":16},{"ruleId":"111","severity":1,"message":"127","line":10,"column":11,"nodeType":"113","messageId":"114","endLine":10,"endColumn":23},{"ruleId":"111","severity":1,"message":"128","line":6,"column":9,"nodeType":"113","messageId":"114","endLine":6,"endColumn":15},{"ruleId":"111","severity":1,"message":"129","line":6,"column":17,"nodeType":"113","messageId":"114","endLine":6,"endColumn":22},{"ruleId":"111","severity":1,"message":"130","line":7,"column":9,"nodeType":"113","messageId":"114","endLine":7,"endColumn":26},{"ruleId":"111","severity":1,"message":"131","line":23,"column":5,"nodeType":"113","messageId":"114","endLine":23,"endColumn":12},{"ruleId":"132","severity":1,"message":"133","line":41,"column":25,"nodeType":"134","messageId":"135","endLine":41,"endColumn":27},{"ruleId":"132","severity":1,"message":"133","line":389,"column":25,"nodeType":"134","messageId":"135","endLine":389,"endColumn":27},{"ruleId":"111","severity":1,"message":"136","line":762,"column":5,"nodeType":"113","messageId":"114","endLine":762,"endColumn":19},{"ruleId":"111","severity":1,"message":"137","line":789,"column":3,"nodeType":"113","messageId":"114","endLine":789,"endColumn":8},{"ruleId":"111","severity":1,"message":"138","line":843,"column":6,"nodeType":"113","messageId":"114","endLine":843,"endColumn":15},{"ruleId":"111","severity":1,"message":"139","line":852,"column":6,"nodeType":"113","messageId":"114","endLine":852,"endColumn":19},{"ruleId":"120","severity":1,"message":"140","line":865,"column":100,"nodeType":"122","messageId":"141","endLine":865,"endColumn":102},{"ruleId":"111","severity":1,"message":"142","line":891,"column":7,"nodeType":"113","messageId":"114","endLine":891,"endColumn":25},{"ruleId":"111","severity":1,"message":"143","line":1083,"column":3,"nodeType":"113","messageId":"114","endLine":1083,"endColumn":20},{"ruleId":"111","severity":1,"message":"144","line":1114,"column":8,"nodeType":"113","messageId":"114","endLine":1114,"endColumn":16},{"ruleId":"111","severity":1,"message":"145","line":1131,"column":5,"nodeType":"113","messageId":"114","endLine":1131,"endColumn":9},{"ruleId":"111","severity":1,"message":"146","line":15,"column":8,"nodeType":"113","messageId":"114","endLine":15,"endColumn":19},{"ruleId":"147","severity":1,"message":"148","line":36,"column":5,"nodeType":"149","endLine":36,"endColumn":16,"suggestions":"150"},{"ruleId":"111","severity":1,"message":"151","line":7,"column":10,"nodeType":"113","messageId":"114","endLine":7,"endColumn":16},{"ruleId":"152","replacedBy":"153"},{"ruleId":"154","replacedBy":"155"},{"ruleId":"152","replacedBy":"156"},{"ruleId":"154","replacedBy":"157"},{"ruleId":"111","severity":1,"message":"158","line":2,"column":51,"nodeType":"113","messageId":"114","endLine":2,"endColumn":65},{"ruleId":"111","severity":1,"message":"159","line":5,"column":37,"nodeType":"113","messageId":"114","endLine":5,"endColumn":47},{"ruleId":"111","severity":1,"message":"160","line":5,"column":49,"nodeType":"113","messageId":"114","endLine":5,"endColumn":64},{"ruleId":"111","severity":1,"message":"161","line":6,"column":10,"nodeType":"113","messageId":"114","endLine":6,"endColumn":31},{"ruleId":"111","severity":1,"message":"162","line":71,"column":6,"nodeType":"113","messageId":"114","endLine":71,"endColumn":23},{"ruleId":"111","severity":1,"message":"163","line":77,"column":6,"nodeType":"113","messageId":"114","endLine":77,"endColumn":21},{"ruleId":"147","severity":1,"message":"164","line":106,"column":5,"nodeType":"149","endLine":106,"endColumn":70,"suggestions":"165"},{"ruleId":"147","severity":1,"message":"166","line":106,"column":6,"nodeType":"167","endLine":106,"endColumn":69},"@typescript-eslint/no-unused-vars","'possible_compart_errors' is assigned a value but never used.","Identifier","unusedVar","'speciesSchema' is assigned a value but never used.","'annotSpecies' is defined but never used.","'species' is defined but never used.","'new_species' is assigned a value but never used.","'species_list' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'species_id' is assigned a value but never used.","'Row' is defined but never used.","'yup' is defined but never used.","'envVarFormat' is defined but never used.","'strict' is assigned a value but never used.","'match' is assigned a value but never used.","'ENGINE_METHOD_DSA' is assigned a value but never used.","'get_env' is assigned a value but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","'validate_model' is assigned a value but never used.","'error' is assigned a value but never used.","'check_env' is assigned a value but never used.","'check_compart' is assigned a value but never used.","Array.prototype.filter() expects a value to be returned at the end of arrow function.","expectedAtEnd","'check_annotspecies' is assigned a value but never used.","'annotSpecies_list' is assigned a value but never used.","'reversed' is assigned a value but never used.","'test' is assigned a value but never used.","'modelChange' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'updateAnnot' and 'updateComparts'. Either include them or remove the dependency array.","ArrayExpression",["168"],"'render' is defined but never used.","no-native-reassign",["169"],"no-negated-in-lhs",["170"],["169"],["170"],"'DropdownButton' is defined but never used.","'withFormik' is defined but never used.","'yupToFormErrors' is defined but never used.","'transform_json_visual' is defined but never used.","'empty_speciesType' is assigned a value but never used.","'empty_bind_site' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'model.modelJson'. Either include it or remove the dependency array.",["171"],"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","CallExpression",{"desc":"172","fix":"173"},"no-global-assign","no-unsafe-negation",{"desc":"174","fix":"175"},"Update the dependencies array to be: [modelJson, updateAnnot, updateComparts]",{"range":"176","text":"177"},"Update the dependencies array to be: [model.modelJson]",{"range":"178","text":"179"},[1276,1287],"[modelJson, updateAnnot, updateComparts]",[2643,2708],"[model.modelJson]"]